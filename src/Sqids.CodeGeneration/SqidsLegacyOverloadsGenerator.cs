using System.Text;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Sqids.CodeGeneration;

[Generator]
public class SqidsLegacyOverloadsGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context) {
		var provider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: (s, _) => s is ClassDeclarationSyntax c && c.AttributeLists.Count > 0,
				transform: (ctx, _) => GetTarget(ctx))
			.Where(m => m is not null)
			.Select((m, _) => m!.Value);

		context.RegisterSourceOutput(provider, Execute);
	}

	private static (string Name, string Namespace)? GetTarget(GeneratorSyntaxContext ctx) {
		var classDecl = (ClassDeclarationSyntax)ctx.Node;
		var symbol = ctx.SemanticModel.GetDeclaredSymbol(classDecl);

		if (symbol is null || !symbol.GetAttributes().Any(a => a.AttributeClass?.Name.StartsWith("GenerateSqidsLegacyOverloads") == true))
			return null;

		return (symbol.Name, symbol.ContainingNamespace.ToDisplayString());
	}

	private static void Execute(SourceProductionContext context, (string Name, string Namespace) target) {
		// Format: (Suffix, CLS-Compliant)
		var types = new (string Suffix, bool IsCls)[] {
			("Byte",   true),
			("SByte",  false),
			("Short",  true),
			("UShort", false),
			("Int",    true), 
			("UInt",   false),
			("Long",   true),
			("ULong",  false) 
		};

		var sb = new StringBuilder();

		// Note: usings may not be needed depending on context but included for safety
		sb.AppendLine($$"""
                // <auto-generated/>
                #if !NET7_0_OR_GREATER
                using System;
                using System.Collections.Generic;
                using System.Linq;

                namespace {{target.Namespace}};

                public sealed partial class {{target.Name}}
                {
                """);

		foreach (var (suffix, isCls) in types) {
			var t = suffix.ToLowerInvariant();
			var clsAttr = isCls ? "" : "\r\n    [CLSCompliant(false)]";

			// Encode Methods (int Encode methods are kept in the main class for increased readability)
			if (t != "int") {
				// Handle cast expression edge cases (identity for ulong, direct cast for uint, cast & Check() for others)
				var castExpr = t == "ulong" ? "n" : t == "uint" ? "(ulong)n" : "(ulong)Check(n)";
				// Handle ulong collection expression edge case (no conversion needed)
				var colExpr = t == "ulong" ? "[.. numbers]" : $"[.. numbers.Select(n => {castExpr})]";

				static string GetEncodeXmlComment(bool isParams) => $$"""
					    /// <summary>Encodes {{(isParams ? "one or more" : "a collection of")}} numbers into a Sqids ID.</summary>
					    /// <param name="numbers">The {{(isParams ? "number or " : "")}}numbers to encode.</param>
					    /// <returns>A string containing the encoded IDs, or an empty string if the `IEnumerable` passed is empty.</returns>
					    /// <exception cref="T:System.ArgumentOutOfRangeException">If any of the numbers passed is smaller than 0 (i.e. negative).</exception>
					    /// <exception cref="T:System.ArgumentException">If the encoding reaches maximum re-generation attempts due to the blocklist.</exception>
					""";

				sb.AppendLine($$"""
                    {{GetEncodeXmlComment(isParams: true)}}{{clsAttr}}
                        public string Encode(params {{t}}[] numbers) => EncodeCore({{colExpr}});

                    {{GetEncodeXmlComment(isParams: false)}}{{clsAttr}}
                        public string Encode(IEnumerable<{{t}}> numbers) => EncodeCore({{colExpr}});

                    """);
			}

			static string GetDecodeXmlComment() => $$"""
					/// <summary>Decodes an ID into numbers.</summary>
				    /// <param name="id">The encoded ID.</param>
				    /// <returns>
				    /// An array containing the decoded number(s) (it would contain only one element
				    /// if the ID represents a single number); or an empty array if the input ID is null,
				    /// empty, or includes characters not found in the alphabet.
				    /// </returns>
				""";

			// Decode Methods
			// ulong returns IReadOnlyList<ulong> directly so no need to cast
			var retType = t == "ulong" ? "DecodeCore(id)" : $"[.. DecodeCore(id).Select(v => ({t})v)]";
			var retTypeSpan = t == "ulong" ? "DecodeCore(id.AsSpan())" : $"[.. DecodeCore(id.AsSpan()).Select(v => ({t})v)]";

			sb.AppendLine($$"""
                {{GetDecodeXmlComment()}}{{clsAttr}}
                    public IReadOnlyList<{{t}}> Decode{{suffix}}(ReadOnlySpan<char> id) => {{retType}};

                {{GetDecodeXmlComment()}}{{clsAttr}}
                    public IReadOnlyList<{{t}}> Decode{{suffix}}(string id) => {{retTypeSpan}};

                """);
		}

		sb.AppendLine("}");
		sb.AppendLine("#endif");

		context.AddSource($"{target.Name}.Legacy.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
	}
}
